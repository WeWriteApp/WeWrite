/**
 * Email Settings Token Service
 *
 * Manages secure tokens for no-login email preference management.
 * Each user has a unique, long-lived token stored in their user document
 * that allows them to manage email preferences directly from email links.
 *
 * Security considerations:
 * - Tokens are randomly generated UUIDs
 * - Tokens are stored per-user (not in a separate collection)
 * - Tokens can be regenerated by the user if compromised
 * - Tokens only grant access to email preferences, not full account access
 */

import { getFirebaseAdmin } from '../firebase/admin';
import { randomUUID } from 'crypto';

const isDev = process.env.NODE_ENV === 'development';
const collectionPrefix = isDev ? 'DEV_' : '';

export interface EmailSettingsTokenData {
  userId: string;
  email: string;
  username?: string;
}

/**
 * Generate a new email settings token for a user
 * This is called when a user is created or when they request a new token
 */
export async function generateEmailSettingsToken(userId: string): Promise<string> {
  const admin = getFirebaseAdmin();
  const db = admin.firestore();

  const token = randomUUID();

  await db.collection(`${collectionPrefix}users`).doc(userId).update({
    emailSettingsToken: token,
    emailSettingsTokenCreatedAt: new Date().toISOString(),
  });

  return token;
}

/**
 * Get or create an email settings token for a user
 * Returns existing token if present, otherwise generates a new one
 */
export async function getOrCreateEmailSettingsToken(userId: string): Promise<string> {
  const admin = getFirebaseAdmin();
  const db = admin.firestore();

  const userDoc = await db.collection(`${collectionPrefix}users`).doc(userId).get();
  const userData = userDoc.data();

  if (userData?.emailSettingsToken) {
    return userData.emailSettingsToken;
  }

  // Generate new token if doesn't exist
  return generateEmailSettingsToken(userId);
}

/**
 * Validate an email settings token and return the associated user data
 * Returns null if token is invalid
 */
export async function validateEmailSettingsToken(token: string): Promise<EmailSettingsTokenData | null> {
  if (!token || token.length < 32) {
    return null;
  }

  const admin = getFirebaseAdmin();
  const db = admin.firestore();

  // Query for user with this token
  const usersQuery = await db.collection(`${collectionPrefix}users`)
    .where('emailSettingsToken', '==', token)
    .limit(1)
    .get();

  if (usersQuery.empty) {
    return null;
  }

  const userDoc = usersQuery.docs[0];
  const userData = userDoc.data();

  return {
    userId: userDoc.id,
    email: userData.email || '',
    username: userData.username,
  };
}

/**
 * Get email preferences for a user by their settings token
 */
export async function getPreferencesByToken(token: string): Promise<{
  success: boolean;
  preferences?: Record<string, boolean>;
  userData?: EmailSettingsTokenData;
  error?: string;
}> {
  const tokenData = await validateEmailSettingsToken(token);

  if (!tokenData) {
    return { success: false, error: 'Invalid or expired token' };
  }

  const admin = getFirebaseAdmin();
  const db = admin.firestore();

  const userDoc = await db.collection(`${collectionPrefix}users`).doc(tokenData.userId).get();
  const userData = userDoc.data();

  const defaultPreferences = {
    securityAlerts: true,
    loginNotifications: true,
    newFollower: true,
    pageComments: true,
    pageLinks: true,
    userMentions: true,
    payoutReminders: true,
    paymentReceipts: true,
    earningsSummary: true,
    weeklyDigest: true,
    productUpdates: true,
    tipsAndTricks: false,
  };

  return {
    success: true,
    preferences: { ...defaultPreferences, ...userData?.emailPreferences },
    userData: tokenData,
  };
}

/**
 * Update email preferences for a user by their settings token
 */
export async function updatePreferencesByToken(
  token: string,
  preferences: Record<string, boolean>
): Promise<{ success: boolean; error?: string }> {
  const tokenData = await validateEmailSettingsToken(token);

  if (!tokenData) {
    return { success: false, error: 'Invalid or expired token' };
  }

  const admin = getFirebaseAdmin();
  const db = admin.firestore();

  // Validate and sanitize preferences
  const validKeys = [
    'securityAlerts', 'loginNotifications', 'newFollower', 'pageComments',
    'pageLinks', 'userMentions', 'payoutReminders', 'paymentReceipts',
    'earningsSummary', 'weeklyDigest', 'productUpdates', 'tipsAndTricks'
  ];

  const sanitizedPreferences: Record<string, boolean> = {};
  for (const key of validKeys) {
    if (key in preferences) {
      sanitizedPreferences[key] = Boolean(preferences[key]);
    }
  }

  // Security alerts must always be enabled
  sanitizedPreferences.securityAlerts = true;

  await db.collection(`${collectionPrefix}users`).doc(tokenData.userId).update({
    emailPreferences: sanitizedPreferences,
    emailPreferencesUpdatedAt: new Date().toISOString(),
  });

  return { success: true };
}

/**
 * Unsubscribe a user from a specific email type using their token
 */
export async function unsubscribeByToken(
  token: string,
  emailType: string
): Promise<{ success: boolean; error?: string }> {
  const tokenData = await validateEmailSettingsToken(token);

  if (!tokenData) {
    return { success: false, error: 'Invalid or expired token' };
  }

  // Map email types to preference keys
  const emailTypeToPreference: Record<string, string> = {
    'weekly-digest': 'weeklyDigest',
    'new-follower': 'newFollower',
    'page-linked': 'pageLinks',
    'payout-reminder': 'payoutReminders',
    'payout-processed': 'paymentReceipts',
    'product-update': 'productUpdates',
    'earnings-summary': 'earningsSummary',
    'tips': 'tipsAndTricks',
    'comments': 'pageComments',
    'mentions': 'userMentions',
    // Allow unsubscribing from all non-essential
    'all': 'all',
  };

  const preferenceKey = emailTypeToPreference[emailType];

  if (!preferenceKey) {
    return { success: false, error: 'Invalid email type' };
  }

  const admin = getFirebaseAdmin();
  const db = admin.firestore();

  const userDoc = await db.collection(`${collectionPrefix}users`).doc(tokenData.userId).get();
  const userData = userDoc.data();
  const currentPreferences = userData?.emailPreferences || {};

  let updatedPreferences: Record<string, boolean>;

  if (preferenceKey === 'all') {
    // Unsubscribe from all non-essential emails
    updatedPreferences = {
      securityAlerts: true, // Always enabled
      loginNotifications: false,
      newFollower: false,
      pageComments: false,
      pageLinks: false,
      userMentions: false,
      payoutReminders: false,
      paymentReceipts: false,
      earningsSummary: false,
      weeklyDigest: false,
      productUpdates: false,
      tipsAndTricks: false,
    };
  } else {
    // Unsubscribe from specific type
    updatedPreferences = {
      ...currentPreferences,
      [preferenceKey]: false,
    };
    // Ensure security alerts stay enabled
    updatedPreferences.securityAlerts = true;
  }

  await db.collection(`${collectionPrefix}users`).doc(tokenData.userId).update({
    emailPreferences: updatedPreferences,
    emailPreferencesUpdatedAt: new Date().toISOString(),
  });

  return { success: true };
}

/**
 * Build the email settings URL for a user
 */
export function buildEmailSettingsUrl(token: string, emailType?: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://getwewrite.app';

  if (emailType) {
    return `${baseUrl}/email-preferences/${token}?type=${emailType}`;
  }

  return `${baseUrl}/email-preferences/${token}`;
}

/**
 * Build the one-click unsubscribe URL for a specific email type
 */
export function buildUnsubscribeUrl(token: string, emailType: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://getwewrite.app';
  return `${baseUrl}/api/email/unsubscribe?token=${token}&type=${emailType}`;
}
