/**
 * Username Reminder Email Cron Job
 * 
 * Sends reminder emails to users who haven't set up a proper username.
 * Run daily via Vercel cron to catch users who signed up but didn't complete profile.
 * 
 * Add to vercel.json:
 * {
 *   "crons": [{
 *     "path": "/api/cron/username-reminder",
 *     "schedule": "0 14 * * *"
 *   }]
 * }
 */

import { NextRequest, NextResponse } from 'next/server';
import { getFirebaseAdmin } from '../../../firebase/firebaseAdmin';
import { getCollectionName } from '../../../utils/environmentConfig';
import { sendTemplatedEmail, EmailPriority } from '../../../services/emailService';

export const maxDuration = 120; // 2 minute timeout

/**
 * GET handler for Vercel cron jobs
 */
export async function GET(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    // Verify cron access - Vercel sends CRON_SECRET in Authorization header
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;

    // Check Authorization: Bearer <CRON_SECRET> header (Vercel's standard)
    const isAuthorized = cronSecret && authHeader === `Bearer ${cronSecret}`;

    if (!isAuthorized && process.env.NODE_ENV === 'production') {
      console.warn('[USERNAME REMINDER] Unauthorized access attempt - check CRON_SECRET env var');
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    console.log('[USERNAME REMINDER] Starting username reminder processing');
    
    const admin = getFirebaseAdmin();
    if (!admin) {
      return NextResponse.json({ error: 'Database not available' }, { status: 503 });
    }
    
    const db = admin.firestore();

    // Find ALL users without proper usernames who signed up at least 1 day ago
    // Changed from 1-7 days to ALL TIME to catch existing users who never set username
    const oneDayAgo = new Date();
    oneDayAgo.setDate(oneDayAgo.getDate() - 1);

    // Helper to parse various date formats
    const getDateValue = (val: any): Date | null => {
      if (!val) return null;
      if (val._seconds) return new Date(val._seconds * 1000);
      if (val.toDate) return val.toDate();
      if (typeof val === 'string') return new Date(val);
      return null;
    };

    // Query all users and filter - broader net to catch existing users
    const usersSnapshot = await db.collection(getCollectionName('users'))
      .limit(500)
      .get();
    
    console.log(`[USERNAME REMINDER] Found ${usersSnapshot.size} users to check for missing usernames`);
    
    let sent = 0;
    let scheduled = 0;
    let skipped = 0;
    let failed = 0;
    
    for (const userDoc of usersSnapshot.docs) {
      try {
        const userData = userDoc.data();
        const userId = userDoc.id;

        // Skip users without email
        if (!userData.email) {
          skipped++;
          continue;
        }

        // Check if user signed up at least 1 day ago
        const createdAt = getDateValue(userData.createdAt);
        if (!createdAt || createdAt > oneDayAgo) {
          skipped++;
          continue;
        }

        // Skip users who already have a proper username
        const username = userData.username || '';
        const usernameLower = username.toLowerCase();

        // A proper username is one that:
        // - Exists and has at least 2 characters (many valid usernames like "Rae", "Abe", "tim" are 3 chars)
        // - Doesn't start with 'user_' (auto-generated pattern)
        // - Doesn't match the pattern 'user_xxxxxxxx' (8 hex chars from userId)
        const isAutoGenerated = usernameLower.startsWith('user_') ||
          /^user_[a-f0-9]{8}$/i.test(username);
        const hasProperUsername = username &&
          username.length >= 2 &&
          !isAutoGenerated;

        if (hasProperUsername) {
          skipped++;
          continue;
        }

        // Skip users who already received this reminder (check metadata)
        if (userData.usernameReminderSent) {
          skipped++;
          continue;
        }

        // Skip users who opted out of engagement emails
        if (userData.emailPreferences?.engagement === false) {
          skipped++;
          continue;
        }
        
        // Send the reminder email
        // Auto-schedules for later if daily quota is reached
        const result = await sendTemplatedEmail({
          templateId: 'choose-username',
          to: userData.email,
          data: {
            currentUsername: username || `user_${userId.slice(0, 8)}`
          },
          userId,
          triggerSource: 'cron',
          priority: EmailPriority.P2_ENGAGEMENT,
        });

        if (result.success) {
          // Mark that we sent/scheduled the reminder
          await userDoc.ref.update({
            usernameReminderSent: true,
            usernameReminderSentAt: admin.firestore.FieldValue.serverTimestamp(),
            ...(result.wasScheduled && { usernameReminderScheduledFor: result.scheduledFor })
          });
          if (result.wasScheduled) {
            scheduled++;
          } else {
            sent++;
          }
        } else {
          failed++;
        }
        
        // Rate limit
        if (sent % 10 === 0) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
      } catch (userError) {
        console.error(`[USERNAME REMINDER] Error processing user ${userDoc.id}:`, userError);
        failed++;
      }
    }
    
    const duration = Date.now() - startTime;
    console.log(`[USERNAME REMINDER] Completed in ${duration}ms - Sent: ${sent}, Scheduled: ${scheduled}, Skipped: ${skipped}, Failed: ${failed}`);

    return NextResponse.json({
      success: true,
      summary: {
        totalChecked: usersSnapshot.size,
        sentImmediately: sent,
        scheduledForLater: scheduled,
        skipped,
        failed,
        durationMs: duration
      }
    });
    
  } catch (error) {
    console.error('[USERNAME REMINDER] Error:', error);
    return NextResponse.json({
      error: 'Failed to process username reminders',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
