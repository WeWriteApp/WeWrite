/**
 * Admin Trigger Cron API
 *
 * Allows admins to manually trigger cron jobs with optional scheduling.
 * Useful for testing and immediate action.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getFirebaseAdmin } from '../../../firebase/firebaseAdmin';
import { getCollectionName, getEnvironmentType } from '../../../utils/environmentConfig';
import { PRODUCTION_URL } from '../../../utils/urlConfig';
import { isAdmin } from '../../../utils/isAdmin';
import { randomUUID } from 'crypto';
import { sendTemplatedEmail } from '../../../services/emailService';

export const maxDuration = 120;

export async function POST(request: NextRequest) {
  try {
    // Verify admin access
    const userEmail = request.headers.get('x-user-email');
    if (!userEmail || !isAdmin(userEmail)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { cronId, scheduledAt, limit = 50 } = body;

    if (!cronId) {
      return NextResponse.json({ error: 'cronId required' }, { status: 400 });
    }

    const admin = getFirebaseAdmin();
    if (!admin) {
      return NextResponse.json({ error: 'Database not available' }, { status: 503 });
    }

    const db = admin.firestore();
    const envType = getEnvironmentType();

    // IMPORTANT: Check if we're forcing production data via header
    // When admin is using localhost but targeting prod data, we MUST use production URLs
    // Otherwise prod users would get emails with localhost links!
    const forceProductionData = request.headers.get('x-force-production-data') === 'true';
    const baseUrl = (envType === 'production' || forceProductionData)
      ? PRODUCTION_URL
      : process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';

    let sent = 0;
    let skipped = 0;
    let failed = 0;

    // Helper to parse various date formats
    const getDateValue = (val: any): Date | null => {
      if (!val) return null;
      if (val._seconds) return new Date(val._seconds * 1000);
      if (val.toDate) return val.toDate();
      if (typeof val === 'string') return new Date(val);
      return null;
    };

    // Helper to check if username is proper (not auto-generated)
    const hasProperUsername = (username: string | undefined): boolean => {
      if (!username || username.length < 2) return false;
      const usernameLower = username.toLowerCase();
      const isAutoGenerated = usernameLower.startsWith('user_') ||
        /^user_[a-f0-9]{8}$/i.test(username);
      return !isAutoGenerated;
    };

    switch (cronId) {
      case 'email-verification-reminder': {
        // Only for unverified users who HAVE a proper username
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const usersSnapshot = await db.collection(getCollectionName('users'))
          .limit(500)
          .get();

        for (const userDoc of usersSnapshot.docs) {
          if (sent >= limit) break;

          const userData = userDoc.data();
          const userId = userDoc.id;

          if (!userData.email) { skipped++; continue; }
          if (userData.emailVerified) { skipped++; continue; }
          if (userData.emailPreferences?.engagement === false) { skipped++; continue; }

          // Only include users who HAVE a proper username
          if (!hasProperUsername(userData.username)) { skipped++; continue; }

          const createdAt = getDateValue(userData.createdAt);
          if (!createdAt || createdAt > oneDayAgo) { skipped++; continue; }

          const lastReminderSent = getDateValue(userData.verificationReminderSentAt);
          if (lastReminderSent && lastReminderSent > sevenDaysAgo) { skipped++; continue; }

          // Generate verification token
          const verificationToken = randomUUID();
          const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days for scheduled emails

          await db.collection(getCollectionName('email_verification_tokens')).doc(verificationToken).set({
            userId,
            email: userData.email,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            expiresAt,
            used: false,
            type: 'reminder'
          });

          const verificationLink = `${baseUrl}/auth/verify-email?token=${verificationToken}`;

          const result = await sendTemplatedEmail({
            templateId: 'verification-reminder',
            to: userData.email,
            data: {
              username: userData.username || `user_${userId.slice(0, 8)}`,
              verificationLink
            },
            userId,
            scheduledAt, // Pass through the scheduled time
          });

          if (result.success) {
            await userDoc.ref.update({
              verificationReminderSentAt: admin.firestore.FieldValue.serverTimestamp()
            });
            sent++;
          } else {
            failed++;
          }

          // Rate limit
          if (sent % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        break;
      }

      case 'verify-to-choose-username': {
        // For unverified users who DON'T have a proper username
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const usersSnapshot = await db.collection(getCollectionName('users'))
          .limit(500)
          .get();

        for (const userDoc of usersSnapshot.docs) {
          if (sent >= limit) break;

          const userData = userDoc.data();
          const userId = userDoc.id;

          if (!userData.email) { skipped++; continue; }
          if (userData.emailVerified) { skipped++; continue; } // Must be unverified
          if (hasProperUsername(userData.username)) { skipped++; continue; } // Must NOT have proper username
          if (userData.emailPreferences?.engagement === false) { skipped++; continue; }

          const createdAt = getDateValue(userData.createdAt);
          if (!createdAt || createdAt > oneDayAgo) { skipped++; continue; }

          // Check if we already sent this combined reminder
          const lastReminderSent = getDateValue(userData.verifyToChooseUsernameSentAt);
          if (lastReminderSent && lastReminderSent > sevenDaysAgo) { skipped++; continue; }

          // Generate verification token
          const verificationToken = randomUUID();
          const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

          await db.collection(getCollectionName('email_verification_tokens')).doc(verificationToken).set({
            userId,
            email: userData.email,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            expiresAt,
            used: false,
            type: 'verify-to-choose-username'
          });

          const verificationLink = `${baseUrl}/auth/verify-email?token=${verificationToken}`;

          const result = await sendTemplatedEmail({
            templateId: 'verify-to-choose-username',
            to: userData.email,
            data: {
              currentUsername: userData.username || `user_${userId.slice(0, 8)}`,
              verificationLink
            },
            userId,
            scheduledAt,
          });

          if (result.success) {
            await userDoc.ref.update({
              verifyToChooseUsernameSentAt: admin.firestore.FieldValue.serverTimestamp()
            });
            sent++;
          } else {
            failed++;
          }

          // Rate limit
          if (sent % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        break;
      }

      case 'username-reminder': {
        // Only for VERIFIED users without a proper username
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);

        const usersSnapshot = await db.collection(getCollectionName('users'))
          .limit(500)
          .get();

        for (const userDoc of usersSnapshot.docs) {
          if (sent >= limit) break;

          const userData = userDoc.data();
          const userId = userDoc.id;

          if (!userData.email) { skipped++; continue; }
          if (!userData.emailVerified) { skipped++; continue; } // Must be verified
          if (hasProperUsername(userData.username)) { skipped++; continue; } // Must NOT have proper username
          if (userData.usernameReminderSent) { skipped++; continue; }
          if (userData.emailPreferences?.engagement === false) { skipped++; continue; }

          const createdAt = getDateValue(userData.createdAt);
          if (!createdAt || createdAt > oneDayAgo) { skipped++; continue; }

          const result = await sendTemplatedEmail({
            templateId: 'choose-username',
            to: userData.email,
            data: {
              currentUsername: userData.username || `user_${userId.slice(0, 8)}`,
              profileLink: `${baseUrl}/settings/profile`
            },
            userId,
            scheduledAt,
          });

          if (result.success) {
            await userDoc.ref.update({
              usernameReminderSent: true,
              usernameReminderSentAt: admin.firestore.FieldValue.serverTimestamp()
            });
            sent++;
          } else {
            failed++;
          }

          // Rate limit
          if (sent % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        break;
      }

      default:
        return NextResponse.json({
          error: `Unknown cronId: ${cronId}. Supported: email-verification-reminder, verify-to-choose-username, username-reminder`
        }, { status: 400 });
    }

    return NextResponse.json({
      success: true,
      cronId,
      scheduledAt: scheduledAt || 'immediate',
      summary: { sent, skipped, failed }
    });

  } catch (error) {
    console.error('[ADMIN TRIGGER CRON] Error:', error);
    return NextResponse.json({
      error: 'Failed to trigger cron',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
