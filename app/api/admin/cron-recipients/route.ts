/**
 * Cron Recipients API
 *
 * Returns the list of users who would receive the next scheduled notification
 * for a given cron job. Used by admin notifications page to show upcoming recipients.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getFirebaseAdmin } from '../../../firebase/firebaseAdmin';
import { getCollectionName } from '../../../utils/environmentConfig';
import { checkAdminPermissions } from '../../admin-auth-helper';
import { WEWRITE_FEE_STRUCTURE } from '../../../utils/feeCalculations';
import { withAdminContext } from '../../../utils/adminRequestContext';

// Threshold in cents for payout setup reminder ($25 minimum)
const PAYOUT_THRESHOLD_CENTS = WEWRITE_FEE_STRUCTURE.minimumPayoutThreshold * 100;

export const maxDuration = 30;

interface Recipient {
  userId: string;
  email: string;
  username?: string;
  type: string;
  reason?: string;
}

export async function GET(request: NextRequest) {
  // Wrap the entire handler with admin context for proper environment detection
  return withAdminContext(request, async () => {
  try {
    // Verify admin access using session cookie
    const adminCheck = await checkAdminPermissions(request);
    if (!adminCheck.success) {
      return NextResponse.json({ error: adminCheck.error || 'Admin access required' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const cronId = searchParams.get('cronId');

    if (!cronId) {
      return NextResponse.json({ error: 'cronId required' }, { status: 400 });
    }

    const admin = getFirebaseAdmin();
    if (!admin) {
      return NextResponse.json({ error: 'Database not available' }, { status: 503 });
    }

    const db = admin.firestore();
    const recipients: Recipient[] = [];

    // Pre-compute collection names (async to support X-Force-Production-Data header)
    const usersCollectionName = getCollectionName('users');
    const writerBalancesCollectionName = getCollectionName('writerUsdBalances');

    switch (cronId) {
      case 'username-reminder': {
        // VERIFIED users without proper username who signed up at least 1 day ago
        // Unverified users go to verify-to-choose-username instead
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);

        // Helper to parse various date formats
        const getDateValue = (val: any): Date | null => {
          if (!val) return null;
          if (val._seconds) return new Date(val._seconds * 1000);
          if (val.toDate) return val.toDate();
          if (typeof val === 'string') return new Date(val);
          return null;
        };

        // Query all users and filter - broader net to catch existing users
        const usersSnapshot = await db.collection(usersCollectionName)
          .limit(500)
          .get();

        for (const doc of usersSnapshot.docs) {
          const data = doc.data();
          if (!data.email) continue;

          // IMPORTANT: Only include VERIFIED users
          // Unverified users should get verify-to-choose-username instead
          if (!data.emailVerified) continue;

          // Check if user signed up at least 1 day ago
          const createdAt = getDateValue(data.createdAt);
          if (!createdAt || createdAt > oneDayAgo) continue;

          const username = data.username || '';
          const usernameLower = username.toLowerCase();

          // A proper username is one that:
          // - Exists and has at least 2 characters (many valid usernames like "Rae", "Abe", "tim" are 3 chars)
          // - Doesn't start with 'user_' (auto-generated pattern)
          // - Doesn't match the pattern 'user_xxxxxxxx' (8 hex chars from userId)
          const isAutoGenerated = usernameLower.startsWith('user_') ||
            /^user_[a-f0-9]{8}$/i.test(username);
          const hasProperUsername = username &&
            username.length >= 2 &&
            !isAutoGenerated;

          if (hasProperUsername) continue;
          if (data.usernameReminderSent) continue;
          if (data.emailPreferences?.engagement === false) continue;

          const daysAgo = Math.floor((Date.now() - createdAt.getTime()) / 86400000);

          recipients.push({
            userId: doc.id,
            email: data.email,
            username: data.username,
            type: 'no-username',
            reason: `Signed up ${daysAgo} days ago, verified, username: ${username || 'none'}`
          });

          if (recipients.length >= 50) break; // Limit results for preview
        }
        break;
      }

      case 'payout-setup-reminder': {
        // Users with pending earnings ABOVE PAYOUT THRESHOLD ($25) but no Stripe connected
        // Only users who can actually set up payouts should receive reminders
        const writerBalancesSnapshot = await db.collection(writerBalancesCollectionName)
          .where('pendingUsdCents', '>=', PAYOUT_THRESHOLD_CENTS) // $25 minimum - must meet threshold
          .limit(50)
          .get();

        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

        for (const balanceDoc of writerBalancesSnapshot.docs) {
          const balanceData = balanceDoc.data();
          const userId = balanceDoc.id;

          const userDoc = await db.collection(usersCollectionName).doc(userId).get();
          if (!userDoc.exists) continue;

          const userData = userDoc.data()!;
          if (!userData.email) continue;
          if (userData.stripeConnectedAccountId) continue;

          const lastReminderSent = userData.payoutReminderSentAt?.toDate?.() || userData.payoutReminderSentAt;
          if (lastReminderSent && new Date(lastReminderSent) > oneWeekAgo) continue;
          if (userData.emailPreferences?.payments === false) continue;

          const pendingEarnings = (balanceData.pendingUsdCents || 0) / 100;
          const thresholdDollars = WEWRITE_FEE_STRUCTURE.minimumPayoutThreshold;
          const overThreshold = pendingEarnings - thresholdDollars;

          recipients.push({
            userId,
            email: userData.email,
            username: userData.username,
            type: 'pending-earnings',
            reason: `$${pendingEarnings.toFixed(2)} pending ($${overThreshold.toFixed(2)} over $${thresholdDollars} threshold)`
          });
        }
        break;
      }

      case 'email-verification-reminder': {
        // Unverified users who HAVE a proper username (unverified + no username go to verify-to-choose-username)
        // Graduated retry: 3 days after signup, then 7 days after last send, then 21 days after last send
        // Max 3 reminders total (tracked by verificationReminderCount)
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
        const threeDaysAgo = new Date();
        threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const twentyOneDaysAgo = new Date();
        twentyOneDaysAgo.setDate(twentyOneDaysAgo.getDate() - 21);

        // Helper to parse various date formats
        const getDateValue = (val: any): Date | null => {
          if (!val) return null;
          if (val._seconds) return new Date(val._seconds * 1000);
          if (val.toDate) return val.toDate();
          if (typeof val === 'string') return new Date(val);
          return null;
        };

        // Helper to check if username is proper (not auto-generated)
        const hasProperUsername = (username: string | undefined): boolean => {
          if (!username || username.length < 2) return false;
          const usernameLower = username.toLowerCase();
          const isAutoGenerated = usernameLower.startsWith('user_') ||
            /^user_[a-f0-9]{8}$/i.test(username);
          return !isAutoGenerated;
        };

        // Query all users and filter - can't easily query for emailVerified != true
        const usersSnapshot = await db.collection(usersCollectionName)
          .limit(500)
          .get();

        for (const doc of usersSnapshot.docs) {
          const data = doc.data();
          if (!data.email) continue;
          if (data.emailVerified) continue;
          if (data.emailPreferences?.engagement === false) continue;

          // IMPORTANT: Only include users who HAVE a proper username
          // Users without username should get verify-to-choose-username instead
          if (!hasProperUsername(data.username)) continue;

          // Check signup date - must be at least 1 day old
          const createdAt = getDateValue(data.createdAt);
          if (!createdAt || createdAt > oneDayAgo) continue;

          // Graduated retry logic:
          // - First reminder: 3 days after signup (count = 0 or undefined)
          // - Second reminder: 7 days after first reminder (count = 1)
          // - Third reminder: 21 days after second reminder (count = 2)
          // - No more reminders after 3 (count >= 3)
          const reminderCount = data.verificationReminderCount || 0;
          const lastReminderSent = getDateValue(data.verificationReminderSentAt);

          // Max 3 reminders total
          if (reminderCount >= 3) continue;

          // Check timing based on reminder count
          if (reminderCount === 0) {
            // First reminder: must be at least 3 days since signup
            if (createdAt > threeDaysAgo) continue;
          } else if (reminderCount === 1) {
            // Second reminder: must be at least 7 days since last reminder
            if (lastReminderSent && lastReminderSent > sevenDaysAgo) continue;
          } else if (reminderCount === 2) {
            // Third reminder: must be at least 21 days since last reminder
            if (lastReminderSent && lastReminderSent > twentyOneDaysAgo) continue;
          }

          const daysAgo = Math.floor((Date.now() - createdAt.getTime()) / 86400000);
          const reminderLabel = reminderCount === 0 ? '1st' : reminderCount === 1 ? '2nd' : '3rd (final)';

          recipients.push({
            userId: doc.id,
            email: data.email,
            username: data.username,
            type: 'unverified',
            reason: `Signed up ${daysAgo} days ago, ${reminderLabel} reminder (has username: ${data.username})`
          });

          if (recipients.length >= 50) break;
        }
        break;
      }

      case 'verify-to-choose-username': {
        // Unverified users who DON'T have a proper username
        // Combined email: verify first, then choose username
        // Graduated retry: 3 days after signup, then 7 days after last send, then 21 days after last send
        // Max 3 reminders total (tracked by verifyToChooseUsernameCount)
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
        const threeDaysAgo = new Date();
        threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const twentyOneDaysAgo = new Date();
        twentyOneDaysAgo.setDate(twentyOneDaysAgo.getDate() - 21);

        // Helper to parse various date formats
        const getDateValue = (val: any): Date | null => {
          if (!val) return null;
          if (val._seconds) return new Date(val._seconds * 1000);
          if (val.toDate) return val.toDate();
          if (typeof val === 'string') return new Date(val);
          return null;
        };

        // Helper to check if username is proper (not auto-generated)
        const hasProperUsername = (username: string | undefined): boolean => {
          if (!username || username.length < 2) return false;
          const usernameLower = username.toLowerCase();
          const isAutoGenerated = usernameLower.startsWith('user_') ||
            /^user_[a-f0-9]{8}$/i.test(username);
          return !isAutoGenerated;
        };

        const usersSnapshot = await db.collection(usersCollectionName)
          .limit(500)
          .get();

        for (const doc of usersSnapshot.docs) {
          const data = doc.data();
          if (!data.email) continue;
          if (data.emailVerified) continue; // Must be unverified
          if (hasProperUsername(data.username)) continue; // Must NOT have proper username
          if (data.emailPreferences?.engagement === false) continue;

          // Check signup date - must be at least 1 day old
          const createdAt = getDateValue(data.createdAt);
          if (!createdAt || createdAt > oneDayAgo) continue;

          // Graduated retry logic:
          // - First reminder: 3 days after signup (count = 0 or undefined)
          // - Second reminder: 7 days after first reminder (count = 1)
          // - Third reminder: 21 days after second reminder (count = 2)
          // - No more reminders after 3 (count >= 3)
          const reminderCount = data.verifyToChooseUsernameCount || 0;
          const lastReminderSent = getDateValue(data.verifyToChooseUsernameSentAt);

          // Max 3 reminders total
          if (reminderCount >= 3) continue;

          // Check timing based on reminder count
          if (reminderCount === 0) {
            // First reminder: must be at least 3 days since signup
            if (createdAt > threeDaysAgo) continue;
          } else if (reminderCount === 1) {
            // Second reminder: must be at least 7 days since last reminder
            if (lastReminderSent && lastReminderSent > sevenDaysAgo) continue;
          } else if (reminderCount === 2) {
            // Third reminder: must be at least 21 days since last reminder
            if (lastReminderSent && lastReminderSent > twentyOneDaysAgo) continue;
          }

          const daysAgo = Math.floor((Date.now() - createdAt.getTime()) / 86400000);
          const reminderLabel = reminderCount === 0 ? '1st' : reminderCount === 1 ? '2nd' : '3rd (final)';

          recipients.push({
            userId: doc.id,
            email: data.email,
            username: data.username,
            type: 'unverified-no-username',
            reason: `Signed up ${daysAgo} days ago, ${reminderLabel} reminder, needs verification + username`
          });

          if (recipients.length >= 50) break;
        }
        break;
      }

      case 'weekly-digest': {
        // Weekly digest requirements (from notificationFlow):
        // - requires: email_verified, has_first_page, is_active
        // Only send to users who have written at least one page and are active
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        const usersSnapshot = await db.collection(usersCollectionName)
          .where('emailVerified', '==', true)
          .limit(200)
          .get();

        const rtdb = admin.database();

        // Helper to parse various date formats
        const getDateValue = (val: any): Date | null => {
          if (!val) return null;
          if (val._seconds) return new Date(val._seconds * 1000);
          if (val.toDate) return val.toDate();
          if (typeof val === 'string') return new Date(val);
          return null;
        };

        for (const doc of usersSnapshot.docs) {
          const data = doc.data();
          if (!data.email) continue;
          // Only skip users who EXPLICITLY opted out (set to false)
          if (data.emailPreferences?.weeklyDigest === false) continue;

          // Check if user is active (logged in within last 30 days)
          const lastActivity = getDateValue(data.lastActiveAt)
            || getDateValue(data.lastLoginAt);
          if (!lastActivity || lastActivity < thirtyDaysAgo) continue;

          // Check if user has written at least one page
          const userPagesSnapshot = await rtdb.ref('pages')
            .orderByChild('authorId')
            .equalTo(doc.id)
            .limitToFirst(1)
            .once('value');

          if (!userPagesSnapshot.exists()) continue;

          recipients.push({
            userId: doc.id,
            email: data.email,
            username: data.username,
            type: 'active-writer',
            reason: 'Verified, has pages, active in last 30 days'
          });

          if (recipients.length >= 50) break; // Limit results
        }
        break;
      }

      case 'process-writer-earnings': {
        // Writers with views in the past month
        const oneMonthAgo = new Date();
        oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);

        const writerBalancesSnapshot = await db.collection(writerBalancesCollectionName)
          .limit(50)
          .get();

        for (const balanceDoc of writerBalancesSnapshot.docs) {
          const balanceData = balanceDoc.data();
          const userId = balanceDoc.id;

          // Skip if no recent activity
          const lastUpdated = balanceData.updatedAt?.toDate?.() || balanceData.lastActivityAt?.toDate?.();
          if (lastUpdated && lastUpdated < oneMonthAgo) continue;

          const userDoc = await db.collection(usersCollectionName).doc(userId).get();
          if (!userDoc.exists) continue;

          const userData = userDoc.data()!;

          recipients.push({
            userId,
            email: userData.email || 'N/A',
            username: userData.username,
            type: 'active-writer',
            reason: `Pending: $${((balanceData.pendingUsdCents || 0) / 100).toFixed(2)}`
          });
        }
        break;
      }

      case 'automated-payouts': {
        // Writers with available balance and Stripe connected
        const writerBalancesSnapshot = await db.collection(writerBalancesCollectionName)
          .where('availableUsdCents', '>=', 100)
          .limit(50)
          .get();

        for (const balanceDoc of writerBalancesSnapshot.docs) {
          const balanceData = balanceDoc.data();
          const userId = balanceDoc.id;

          const userDoc = await db.collection(usersCollectionName).doc(userId).get();
          if (!userDoc.exists) continue;

          const userData = userDoc.data()!;
          if (!userData.stripeConnectedAccountId) continue;

          recipients.push({
            userId,
            email: userData.email || 'N/A',
            username: userData.username,
            type: 'payout-eligible',
            reason: `$${((balanceData.availableUsdCents || 0) / 100).toFixed(2)} available`
          });
        }
        break;
      }

      case 'reactivation': {
        // Users who have been inactive for 30-90 days
        // Query all users and filter in code to avoid index requirements
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);

        // Query all users - we filter by activity in code because:
        // 1. lastLoginAt may be stored as string or timestamp inconsistently
        // 2. Some users may have lastActiveAt vs lastLoginAt
        // 3. Avoids needing composite Firestore indexes
        const usersSnapshot = await db.collection(usersCollectionName)
          .limit(500)
          .get();

        for (const doc of usersSnapshot.docs) {
          const data = doc.data();
          if (!data.email) continue;
          if (data.emailPreferences?.engagement === false) continue;
          if (data.emailPreferences?.reactivation === false) continue;

          // Get last activity time - prefer lastActiveAt, fall back to lastLoginAt, then createdAt
          const getDateValue = (val: any): Date | null => {
            if (!val) return null;
            if (val._seconds) return new Date(val._seconds * 1000);
            if (val.toDate) return val.toDate();
            if (typeof val === 'string') return new Date(val);
            return null;
          };

          const lastActivity = getDateValue(data.lastActiveAt)
            || getDateValue(data.lastLoginAt)
            || getDateValue(data.createdAt);

          if (!lastActivity) continue;

          // Check if user is in the 30-90 day inactive window
          if (lastActivity > thirtyDaysAgo || lastActivity < ninetyDaysAgo) continue;

          // Skip if already sent a reactivation email recently (within 60 days)
          const lastReactivationEmail = getDateValue(data.reactivationEmailSentAt);
          if (lastReactivationEmail && lastReactivationEmail > sixtyDaysAgo) continue;

          const daysInactive = Math.floor((now.getTime() - lastActivity.getTime()) / (24 * 60 * 60 * 1000));

          recipients.push({
            userId: doc.id,
            email: data.email,
            username: data.username,
            type: 'inactive-user',
            reason: `Inactive for ${daysInactive} days`
          });

          if (recipients.length >= 50) break; // Limit results
        }
        break;
      }

      case 'first-page-activation': {
        // Users who signed up 2-7 days ago and haven't written their first page
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        const twoDaysAgo = new Date();
        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);

        // Helper to parse various date formats
        const getDateValue = (val: any): Date | null => {
          if (!val) return null;
          if (val._seconds) return new Date(val._seconds * 1000);
          if (val.toDate) return val.toDate();
          if (typeof val === 'string') return new Date(val);
          return null;
        };

        // Query all users and filter in code to handle inconsistent date formats
        const usersSnapshot = await db.collection(usersCollectionName)
          .limit(500)
          .get();

        const rtdb = admin.database();

        for (const doc of usersSnapshot.docs) {
          const data = doc.data();
          if (!data.email) continue;

          // Check if user signed up in the 2-7 day window
          const createdAt = getDateValue(data.createdAt);
          if (!createdAt) continue;

          // Must be older than 2 days but newer than 7 days
          if (createdAt > twoDaysAgo || createdAt < oneWeekAgo) continue;

          if (data.firstPageActivationSent) continue;
          if (data.emailPreferences?.engagement === false) continue;

          // Check if user has any pages in RTDB
          const userPagesSnapshot = await rtdb.ref('pages')
            .orderByChild('authorId')
            .equalTo(doc.id)
            .limitToFirst(1)
            .once('value');

          if (userPagesSnapshot.exists()) continue;

          const daysAgo = Math.floor((Date.now() - createdAt.getTime()) / 86400000);

          recipients.push({
            userId: doc.id,
            email: data.email,
            username: data.username,
            type: 'no-first-page',
            reason: `Signed up ${daysAgo} days ago, no pages yet`
          });

          if (recipients.length >= 50) break; // Limit results
        }
        break;
      }

      default:
        return NextResponse.json({
          success: true,
          recipients: [],
          message: `Unknown cron job: ${cronId}`
        });
    }

    return NextResponse.json({
      success: true,
      cronId,
      recipients,
      totalCount: recipients.length
    });

  } catch (error) {
    console.error('[CRON RECIPIENTS] Error:', error);
    return NextResponse.json({
      error: 'Failed to fetch cron recipients',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
  }); // End withAdminContext
}
